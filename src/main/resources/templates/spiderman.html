<!DOCTYPE html>
<meta name="referrer" content="no-referrer"/>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>暗中观察</title>
    <script th:src="@{/js/jquery-3.4.1.js}" type="text/javascript"></script>
    <script th:src="@{/js/bootstrap.min.js}" type="text/javascript"></script>
    <link th:href="@{/css/bootstrap.min.css}" type="text/css" rel="stylesheet"/>
</head>
<style>
    .i_am {
        padding-top: 1%;
        padding-left: 1%;
    }

</style>
<style>
    * {
        padding: 0;
        margin: 0;
    }

    div {
        display: block;
    }

    #container {
        position: relative;
    }

    .box {
        float: left;
        padding: 5px;
    }

    .box-img img {
        width: 230px;
        height: auto;
    }
</style>
<body>
<div class="i_am">
    <input type="text" id="questionId" class="questionId" placeholder="请输入问题id" value="306181247">
    <button id="spiderManRun" class="btn-info" style="border-radius:4px" onclick="spiderManRun();">Spider Man Run!
    </button>
</div>
<hr>
<div class="spider_man">
    <div id="container">

    </div>
</div>
<script>
    var imgData = [];

    function spiderManRun() {
        var questionId = $("#questionId").val();
        $.get('/spider/' + questionId, function (data) {
            imgData = JSON.parse(data);
            console.log(imgData);

            checkFirstLoading('box');

        })
    }

    /*
        瀑布流的实现思路：
            1.布局：
                1.1 实现图片的列数和浏览器挂钩
                    内容显示区的宽度/盛放图片的容器的宽度
                1.2 让图片居中
            2.根据你每一列的最小高度来计算
                把后面要加载的数据 放在最小高度列的后面
            3.判断滚动条是否滚动到底部
                滚动高度+页面高度>最后一张图片距离浏览器顶部的高度
    */

    var oParent = document.getElementById('container');
    window.addEventListener('scroll', () => {
        console.log("监听滚动事件");
        if (checkLoading('box')) {

            imgData.map((current) => {
                const oDiv = document.createElement('div');
                oDiv.className = 'box';
                oParent.appendChild(oDiv);

                const boxImg = document.createElement('div');
                boxImg.className = 'box-img';
                oDiv.appendChild(boxImg);

                const img = new Image();
                // img.src = 'img/' + current.src + '';
                img.src = current.src + '';
                boxImg.appendChild(img);
            });

            imgLocation('box');
        }

    });
    // window.addEventListener('load', () => {
    //     //imgLocation('box');
    //     this.addEventListener('scroll', () => {
    //         if (checkLoading('box')) {
    //
    //             imgData.map((current) => {
    //                 const oDiv = document.createElement('div');
    //                 oDiv.className = 'box';
    //                 oParent.appendChild(oDiv);
    //
    //                 const boxImg = document.createElement('div');
    //                 boxImg.className = 'box-img';
    //                 oDiv.appendChild(boxImg);
    //
    //                 const img = new Image();
    //                 img.src = 'img/' + current.src + '';
    //                 boxImg.appendChild(img);
    //             });
    //
    //             imgLocation('box');
    //         }
    //
    //     });
    // });

    const imgLocation = (child) => {
        const aContent = getChilds(child);
        console.log("顶级父元素container下符合查找条件的子元素 :");
        console.log(aContent);

        const imgWidth = aContent[0].offsetWidth;
        console.log("每个图片的宽度 :" + imgWidth);

        const num = Math.floor(document.documentElement.clientWidth / imgWidth);
        console.log("根据图片宽度计算出来当前页可放图片的列数 :" + num);

        oParent.style.cssText = 'width:' + imgWidth * num + 'px;margin:0 auto';

        //计算图片的高度
        const heightArr = [];
        [].map.call(aContent, (current, index) => {
            if (index < num) {
                heightArr.push(current.offsetHeight);
            } else {
                //得到上一行图片的最小高度

                //ES5简单写法 可能存在兼容性问题
                //const minHeight = Math.min.apply(Math,heightArr);

                //还有更简单方法 ES6扩展运算符...

                const minHeight = getMinImgHeight(heightArr);
                console.log(minHeight);

                //得到最小高度图片的下标
                const minIndex = getMinImgIndex(minHeight, heightArr);
                console.log("最小高度图片的下标 :" + minIndex);

                //设置当前元素位置放到最小高度图片的下方
                current.style.position = 'absolute';
                current.style.top = minHeight + 'px';
                current.style.left = aContent[minIndex].offsetLeft + 'px';

                //更新图片高度数组
                heightArr[minIndex] += current.offsetHeight;
            }
        });
        console.log("第一行每个图片高度 :" + heightArr);
    };

    //获取指定当前父元素下child元素数组
    const getChilds = (child) => {
        const childArr = [];
        const tagsAll = oParent.getElementsByTagName('*');
        [].map.call(tagsAll, (current) => {
            if (current.className == child) {
                childArr.push(current);
            }
        });
        return childArr;
    };

    //获取指定数组中最小值
    function getMinImgHeight(arr) {
        var arrLength = arr.length;
        for (var i = 0, ret = arr[0]; i < arr.length; i++) {
            ret = Math.min(ret, arr[i]);
        }
        return ret;
    }

    //获取值为最小高度的数组元素的下标
    function getMinImgIndex(minHeight, arr) {
        for (var i in arr) {
            if (arr[i] == minHeight) {
                return i;
            }
        }
    }

    const checkLoading = (child) => {
        const aContent = getChilds(child);

        //最后一个图片的高度
        const lastImgHeight = aContent[aContent.length - 1].offsetTop;
        //滚动高度
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        //页面高度
        const pageHeight = document.documentElement.clientHeight || document.body.clientHeight;
        if (scrollTop + pageHeight > lastImgHeight) {
            return true;
        }
    }

    const checkFirstLoading = (child) => {
        const aContent = getChilds(child);
        console.log(aContent);

        //最后一个图片的高度
        const lastImgHeight = aContent[aContent.length - 1].offsetTop;
        //页面高度
        const pageHeight = document.documentElement.clientHeight || document.body.clientHeight;
        if (aContent.length===0||pageHeight > lastImgHeight) {
            imgData.map((current) => {
                const oDiv = document.createElement('div');
                oDiv.className = 'box';
                oParent.appendChild(oDiv);

                const boxImg = document.createElement('div');
                boxImg.className = 'box-img';
                oDiv.appendChild(boxImg);

                const img = new Image();
                // img.src = 'img/' + current.src + '';
                img.src = current.src + '';
                boxImg.appendChild(img);
            });

            imgLocation('box');
        }
    }
</script>
</body>
</html>